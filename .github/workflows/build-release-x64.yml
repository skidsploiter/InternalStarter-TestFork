name: Build InternalStarter x64 Release (C++ - Refined)

on:
  push:
    branches:
      - main
      - release/* # Trigger on pushes to main or any release branch
  workflow_dispatch: # Allows manual triggering from the GitHub UI

jobs:
  build:
    runs-on: windows-latest # Use a Windows runner for building Windows executables

    steps:
    - name: Checkout Repository
      uses: actions/checkout@v4 # Action to checkout your repository code

    - name: Setup MSBuild and Visual Studio Environment
      # This action ensures that MSBuild and necessary Visual Studio components (like C++ workloads)
      # are correctly configured and added to the PATH.
      # Removed 'vs-version: "2022"' to allow the action to auto-detect the latest compatible VS.
      # 'msbuild-architecture: x64' ensures the 64-bit MSBuild is used.
      uses: microsoft/setup-msbuild@v2
      with:
        msbuild-architecture: x64

    - name: Build Solution (CloudyPublic.sln)
      run: |
        # Build the Visual Studio solution. This solution contains both C# (CloudyPublic)
        # and C++ (Executor) projects. Building the solution should build both.
        # /p:Configuration=Release: Sets the build configuration to Release.
        # /p:Platform=x64: Sets the target platform to x64.
        # /m: Uses multiple CPU cores for faster compilation.
        # /t:Rebuild: Cleans and then builds the solution.
        # The solution file 'CloudyPublic.sln' is expected at the root of the repository.
        echo "Starting MSBuild for CloudyPublic.sln..."
        msbuild CloudyPublic.sln /p:Configuration=Release /p:Platform=x64 /m /t:Rebuild
        if ($LASTEXITCODE -ne 0) {
            echo "::error::MSBuild failed with exit code $LASTEXITCODE"
            exit 1
        }
        echo "MSBuild completed successfully."
      shell: pwsh # Using PowerShell for better error handling and logging

    - name: List files in Executor directory after build (for debugging)
      # This step helps to debug where the Executor.exe might have been placed.
      # It lists all files and directories recursively within the 'Executor' folder.
      run: |
        echo "Listing files in Executor directory..."
        Get-ChildItem -Path .\Executor -Recurse | ForEach-Object { Write-Host $_.FullName }
      shell: pwsh

    - name: Find Built Executable (Executor.exe)
      id: find_exe
      run: |
        # Attempt to find the Executor.exe file.
        # C++ projects typically output to 'Executor\x64\Release\Executor.exe' relative to the solution.
        $expectedPath = Join-Path (Get-Location) "Executor\x64\Release\Executor.exe"
        if (Test-Path $expectedPath) {
            Write-Host "Found Executor.exe at expected path: $expectedPath"
            echo "::set-output name=exe_path::$expectedPath"
        } else {
            Write-Warning "Executor.exe not found at expected path: $expectedPath. Searching broadly..."
            # Fallback: Search for Executor.exe broadly within the Executor directory,
            # filtering for files in 'Release' and 'x64' subdirectories.
            $exePath = Get-ChildItem -Path .\Executor -Recurse -Filter "Executor.exe" | Where-Object { $_.FullName -like "*Release*" -and $_.FullName -like "*x64*" } | Select-Object -ExpandProperty FullName
            if ($exePath) {
                Write-Host "Found Executor.exe broadly at: $exePath"
                echo "::set-output name=exe_path::$exePath"
            } else {
                Write-Error "Executor.exe not found anywhere in expected Release x64 output paths."
                exit 1 # Fail the workflow if the executable isn't found
            }
        }
      shell: pwsh # Use PowerShell for robust path manipulation and checks

    - name: Upload Built Executor.exe as Artifact
      uses: actions/upload-artifact@v4 # Action to upload the build output as an artifact
      with:
        name: InternalStarter-Executor-x64-Release # Name of the artifact
        path: ${{ steps.find_exe.outputs.exe_path }} # Upload the specific Executor.exe file
        retention-days: 7 # How long to retain the artifact (optional)
